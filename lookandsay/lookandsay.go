package main

import (
	"fmt"
	"strconv"
)

func main() {
	var i int
	var matrix [][]int = [][]int{{1, 2, 3}, {6, 7, 8}, {9, 10, 11}}
	fmt.Println("Enter the Number")
	fmt.Scan(&i)
	fmt.Println(convertIntToString(i))
	fmt.Println("Multiplication:", i, getNumberMultiplication(i))
	fmt.Println("matrix:", matrix)

	printMatrixIntoSpiralOrder(matrix)

	/*
		s := "1"
		for j := 0; j < i; j++ {
			s = lookAndcount(s)
			fmt.Println(s)
		}
	*/
	//fmt.Println(s)
}

/*
Look-and-Say Sequence
Find the n’th term in Look-and-say (Or Count and Say) Sequence. The look-and-say sequence is the sequence of below integers:
1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, …

How is above sequence generated?
n’th term in generated by reading (n-1)’th term.

The first term is "1"

Second term is "11", generated by reading first term as "One 1"
(There is one 1 in previous term)

Third term is "21", generated by reading second term as "Two 1"

Fourth term is "1211", generated by reading third term as "One 2 One 1"

and so on

*/
func lookAndcount(s string) (r string) {
	c := s[0]
	nc := 1
	for i := 1; i < len(s); i++ {
		d := s[i]
		if c == d {
			nc++
			continue
		}
		r += strconv.Itoa(nc) + string(c)
		c = d
		nc = 1

	}
	return (r + strconv.Itoa(nc) + string(c))
}

func getNumberMultiplication(num int) string {
	s := []byte(convertIntToString(num))
	//resulted string would be store at max in n+m size
	var result_str = make([]byte, 2*len(s))
	var carry int
	var result int
	for i := 0; i <= len(s); i++ {
		result_str[i] = '0'
	}
	for i := 0; i < len(s); i++ {
		carry = 0
		for j := 0; j < len(s) || carry > 0; j++ {
			if j < len(s) {
				x := int(s[i] - '0')
				y := int(s[j] - '0')
				result = int(result_str[i+j]-'0') + x*y + carry
				fmt.Println("1:", result, x, y)
			} else {
				result = int(result_str[i+j]) + carry
				fmt.Println("at 2::", result)
			}
			c := result % 10
			fmt.Println("at 3:", c)
			result_str[i+j] = byte('0' + c)

			carry = c / 10
		}
	}
	fmt.Println("final str:", result_str, string(result_str))
	return string(result_str)
}
func convertIntToString(num int) string {
	var isSing = false
	var numStr []byte
	if num < 0 {
		isSing = true
		num = -1 * num
	}
	if isSing {
		numStr = append(numStr, byte('-'))
	}
	for num > 0 {
		c := num % 10
		numStr = append(numStr, byte(c+'0'))
		num /= 10
	}
	return string(numStr)
}
func printMatrixIntoSpiralOrder(matrix [][]int) {
	iter := len(matrix[0]) / 2
	for offset := 0; offset < len(matrix[0])-iter; offset++ {
		fmt.Println("offset:", offset, len(matrix[0]), iter)
		printMatrixIntoSpiralOrderHelper(matrix, offset)
	}
}

func printMatrixIntoSpiralOrderHelper(matrix [][]int, offset int) {
	if offset == (len(matrix[0]) - offset - 1) { //For Square matrix of Odd size
		fmt.Println(matrix[offset][offset])
	}
	size := len(matrix[0])
	m := size - offset - 1
	for i := offset; i < m; i++ {
		fmt.Println(matrix[offset][i])
	}
	for j := offset; j < m; j++ {
		fmt.Println(matrix[j][m])
	}
	for j := m; j > offset; j-- {
		fmt.Println(matrix[m][j])
	}
	for j := m; j > offset; j-- {
		fmt.Println(matrix[j][offset])
	}
}
